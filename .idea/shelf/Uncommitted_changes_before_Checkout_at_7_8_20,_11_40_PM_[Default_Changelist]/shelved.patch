Index: backend/src/main/java/com/google/sps/data/Match.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.java.com.google.sps.data;\n\n\n\nimport main.java.com.google.sps.data.Participant;\n\n/**\n * A match of two participants. Note: Match includes entire Participants (with unique ID per\n * submitted form) instead of just usernames because a username may be involved in multiple matches\n * over time. This issue can be resolved if we delete matches from the datastore after the users are\n * notified of the match.\n */\npublic final class Match {\n\n  /** Datastore entity ID */\n  private final long id;\n  /** First participant */\n  private final Participant firstParticipant;\n  /** Second participant */\n  private final Participant secondParticipant;\n  /** Duration of meeting */\n  private final int duration;\n  /** Time match found */\n  private final long timestamp;\n\n  /** Constructor */\n  public Match(\n      long id,\n      Participant firstParticipant,\n      Participant secondParticipant,\n      int duration,\n      long timestamp) {\n    this.id = id;\n    this.firstParticipant = firstParticipant;\n    this.secondParticipant = secondParticipant;\n    this.duration = duration;\n    this.timestamp = timestamp;\n  }\n\n  public long getId() {\n    return id;\n  }\n\n  public Participant getFirstParticipant() {\n    return firstParticipant;\n  }\n\n  public Participant getSecondParticipant() {\n    return secondParticipant;\n  }\n\n  public int getDuration() {\n    return duration;\n  }\n\n  public long getTimestamp() {\n    return timestamp;\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- backend/src/main/java/com/google/sps/data/Match.java	(revision f3fc4ff3189002ce2411a5b49fec36cbadefb128)
+++ backend/src/main/java/com/google/sps/data/Match.java	(date 1594265991247)
@@ -1,7 +1,5 @@
 package main.java.com.google.sps.data;
 
-
-
 import main.java.com.google.sps.data.Participant;
 
 /**
Index: backend/src/main/java/com/google/sps/servlets/SearchMatchServlet.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage com.google.sps.servlets;\n\nimport com.google.appengine.api.datastore.DatastoreService;\nimport com.google.appengine.api.datastore.DatastoreServiceFactory;\nimport com.google.appengine.api.datastore.Entity;\nimport com.google.appengine.api.datastore.PreparedQuery;\nimport com.google.appengine.api.datastore.Query;\nimport com.google.appengine.api.datastore.Query.SortDirection;\nimport com.google.appengine.api.users.UserService;\nimport com.google.appengine.api.users.UserServiceFactory;\nimport com.google.sps.data.Match;\nimport com.google.sps.data.Participant;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.json.simple.JSONObject;\n\n/** Servlet that returns some example content. */\n@WebServlet(\"/api/v1/search-match\")\npublic class SearchMatchServlet extends HttpServlet {\n\n  // Datastore Key/Property constants\n  private static final String KEY_MATCH = \"Match\";\n  private static final String PROPERTY_FIRSTPARTICIPANT = \"firstParticipant\";\n  private static final String PROPERTY_SECONDPARTICIPANT = \"secondParticipant\";\n  private static final String PROPERTY_DURATION = \"duration\";\n  private static final String PROPERTY_TIMESTAMP = \"timestamp\";\n\n  // JSON key constants\n  private static final String KEY_MATCHSTATUS = \"matchStatus\";\n  private static final String KEY_FIRSTPARTICIPANTUSERNAME = \"firstParticipantUsername\";\n  private static final String KEY_SECONDPARTICIPANTUSERNAME = \"secondParticipantUsername\";\n  private static final String KEY_DURATION = \"duration\";\n\n  @Override\n  public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    // Get participant username\n    UserService userService = UserServiceFactory.getUserService();\n    String email = userService.getCurrentUser().getEmail();\n    if (email == null) {\n      response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid email.\");\n      return;\n    }\n    String username = email.split(\"@\")[0];\n\n    // Create and sort queries by time\n    // TODO: eventually sort by startTimeAvailable\n    Query query = new Query(KEY_MATCH).addSort(PROPERTY_TIMESTAMP, SortDirection.DESCENDING);\n\n    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();\n    PreparedQuery results = datastore.prepare(query);\n\n    // Convert list of entities to list of matches\n    List<Match> matches = new ArrayList<Match>();\n    for (Entity entity : results.asIterable()) {\n      long id = (long) entity.getKey().getId();\n      Participant firstParticipant = (Participant) entity.getProperty(PROPERTY_FIRSTPARTICIPANT);\n      Participant secondParticipant = (Participant) entity.getProperty(PROPERTY_SECONDPARTICIPANT);\n      int duration = (int) entity.getProperty(PROPERTY_DURATION);\n      long timestamp = (long) entity.getProperty(PROPERTY_TIMESTAMP);\n      Match match = new Match(id, firstParticipant, secondParticipant, duration, timestamp);\n      matches.add(match);\n    }\n\n    JSONObject matchDoesNotExist = new JSONObject();\n    matchDoesNotExist.put(KEY_MATCHSTATUS, \"false\");\n    String matchDetails = matchDoesNotExist.toString(); // default if no match found\n\n    // Brute force search for match\n    for (Match match : matches) {\n      String firstParticipantUsername = match.getFirstParticipant().getUsername();\n      String secondParticipantUsername = match.getSecondParticipant().getUsername();\n      if (username.equals(firstParticipantUsername) || username.equals(secondParticipantUsername)) {\n        JSONObject matchExists = new JSONObject();\n        matchExists.put(KEY_MATCHSTATUS, \"true\");\n        matchExists.put(KEY_FIRSTPARTICIPANTUSERNAME, firstParticipantUsername);\n        matchExists.put(KEY_SECONDPARTICIPANTUSERNAME, secondParticipantUsername);\n        matchExists.put(KEY_DURATION, match.getDuration());\n        matchDetails = matchExists.toString();\n\n        break;\n      }\n    }\n\n    // Send the JSON back as the response\n    response.setContentType(\"application/json\");\n    response.getWriter().println(matchDetails);\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- backend/src/main/java/com/google/sps/servlets/SearchMatchServlet.java	(revision f3fc4ff3189002ce2411a5b49fec36cbadefb128)
+++ backend/src/main/java/com/google/sps/servlets/SearchMatchServlet.java	(date 1594265991281)
@@ -12,7 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-package com.google.sps.servlets;
+package main.java.com.google.sps.servlets;
 
 import com.google.appengine.api.datastore.DatastoreService;
 import com.google.appengine.api.datastore.DatastoreServiceFactory;
@@ -22,15 +22,15 @@
 import com.google.appengine.api.datastore.Query.SortDirection;
 import com.google.appengine.api.users.UserService;
 import com.google.appengine.api.users.UserServiceFactory;
-import com.google.sps.data.Match;
-import com.google.sps.data.Participant;
 import java.io.IOException;
 import java.util.ArrayList;
+import main.java.com.google.sps.data.Match;
 import java.util.List;
 import javax.servlet.annotation.WebServlet;
 import javax.servlet.http.HttpServlet;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+import main.java.com.google.sps.data.Participant;
 import org.json.simple.JSONObject;
 
 /** Servlet that returns some example content. */
Index: backend/src/main/java/com/google/sps/servlets/AddParticipantServlet.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage com.google.sps.servlets;\n\nimport com.google.appengine.api.datastore.DatastoreService;\nimport com.google.appengine.api.datastore.DatastoreServiceFactory;\nimport com.google.appengine.api.datastore.Entity;\nimport com.google.appengine.api.datastore.Key;\nimport com.google.appengine.api.datastore.KeyFactory;\nimport com.google.appengine.api.datastore.PreparedQuery;\nimport com.google.appengine.api.datastore.Query;\nimport com.google.appengine.api.datastore.Query.SortDirection;\nimport com.google.appengine.api.users.UserService;\nimport com.google.appengine.api.users.UserServiceFactory;\nimport com.google.sps.FindMatchQuery;\nimport com.google.sps.data.Match;\nimport com.google.sps.data.Participant;\nimport java.io.IOException;\nimport java.time.Clock;\nimport java.time.Instant;\nimport java.time.ZoneId;\nimport java.time.ZonedDateTime;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/** Servlet that returns some example content. */\n@WebServlet(\"/api/v1/add-participant\")\npublic class AddParticipantServlet extends HttpServlet {\n\n  // Datastore Key/Property constants\n  private static final String KEY_PARTICIPANT = \"Participant\";\n  private static final String KEY_MATCH = \"Match\";\n  private static final String PROPERTY_USERNAME = \"username\";\n  private static final String PROPERTY_STARTTIMEAVAILABLE = \"startTimeAvailable\";\n  private static final String PROPERTY_ENDTIMEAVAILABLE = \"endTimeAvailable\";\n  private static final String PROPERTY_DURATION = \"duration\";\n  private static final String PROPERTY_TIMESTAMP = \"timestamp\";\n  private static final String PROPERTY_FIRSTPARTICIPANT = \"firstParticipant\";\n  private static final String PROPERTY_SECONDPARTICIPANT = \"secondParticipant\";\n\n  @Override\n  public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    // Request parameter values\n    // TODO: Check input values are filled (before allowing to submit)\n    UserService userService = UserServiceFactory.getUserService();\n    String email = userService.getCurrentUser().getEmail();\n    if (email == null) {\n      response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid email.\");\n      return;\n    }\n    String username = email.split(\"@\")[0];\n\n    String timezone = request.getParameter(\"timezone\");\n    ZoneId zoneId = ZoneId.of(timezone); // TODO: convert input timezone to valid ZoneId\n    ZonedDateTime startTimeAvailable =\n        ZonedDateTime.now(zoneId); // TODO: set to future time if not available now\n    Instant endTimeAvailableInstant =\n        Instant.ofEpochMilli(\n            Long.parseLong(\n                request.getParameter(\"endTimeAvailable\"))); // TODO: figure out input format\n    ZonedDateTime endTimeAvailable = endTimeAvailableInstant.atZone(zoneId);\n\n    int duration = convertToPositiveInt(request.getParameter(\"duration\"));\n    if (duration <= 0) {\n      response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid duration.\");\n      return;\n    }\n\n    long timestamp = System.currentTimeMillis();\n\n    // id is irrelevant, only relevant when getting from datastore\n    Participant newParticipant =\n        new Participant(\n            /* id= */ -1L, username, startTimeAvailable, endTimeAvailable, duration, timestamp);\n\n    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();\n\n    // Find immediate match if possibl;\n    FindMatchQuery query = new FindMatchQuery(Clock.systemUTC());\n    Match match = query.findMatch(getParticipants(datastore), newParticipant);\n\n    // Match found, add to datastore, delete matched participants from datastore\n    if (match != null) {\n      addMatchToDatastore(match, datastore);\n      deleteParticipantFromDatastore(match.getSecondParticipant(), datastore);\n    } else {\n      // Match not found, insert participant entity into datastore\n      Entity participantEntity = new Entity(KEY_PARTICIPANT);\n      participantEntity.setProperty(PROPERTY_USERNAME, username);\n      participantEntity.setProperty(PROPERTY_STARTTIMEAVAILABLE, startTimeAvailable);\n      participantEntity.setProperty(PROPERTY_ENDTIMEAVAILABLE, endTimeAvailable);\n      participantEntity.setProperty(PROPERTY_DURATION, duration);\n      participantEntity.setProperty(PROPERTY_TIMESTAMP, timestamp);\n      datastore.put(participantEntity);\n    }\n\n    // Redirect back to the HTML page\n    response.sendRedirect(\"/index.html\");\n  }\n\n  /** Return list of current participants from datastore */\n  private List<Participant> getParticipants(DatastoreService datastore) {\n    // TODO: only return participants who are available now (not sometime in future)\n\n    // Create and sort participant queries by time\n    Query query = new Query(KEY_PARTICIPANT).addSort(\"timestamp\", SortDirection.DESCENDING);\n    PreparedQuery results = datastore.prepare(query);\n\n    // Convert list of entities to list of participants\n    List<Participant> participants = new ArrayList<Participant>();\n    for (Entity entity : results.asIterable()) {\n      long id = (long) entity.getKey().getId();\n      String username = (String) entity.getProperty(PROPERTY_USERNAME);\n      ZonedDateTime startTimeAvailable =\n          (ZonedDateTime) entity.getProperty(PROPERTY_STARTTIMEAVAILABLE);\n      ZonedDateTime endTimeAvailable =\n          (ZonedDateTime) entity.getProperty(PROPERTY_ENDTIMEAVAILABLE);\n      int duration = (int) entity.getProperty(PROPERTY_DURATION);\n      long timestamp = (long) entity.getProperty(PROPERTY_TIMESTAMP);\n      Participant currParticipant =\n          new Participant(id, username, startTimeAvailable, endTimeAvailable, duration, timestamp);\n      participants.add(currParticipant);\n    }\n    return participants;\n  }\n\n  /** Add Match pair to datastore */\n  private void addMatchToDatastore(Match match, DatastoreService datastore) {\n    // Set properties of entity\n    Entity matchEntity = new Entity(KEY_MATCH);\n    matchEntity.setProperty(PROPERTY_FIRSTPARTICIPANT, match.getFirstParticipant());\n    matchEntity.setProperty(PROPERTY_SECONDPARTICIPANT, match.getSecondParticipant());\n    matchEntity.setProperty(PROPERTY_DURATION, match.getDuration());\n    matchEntity.setProperty(PROPERTY_TIMESTAMP, match.getTimestamp());\n\n    // Insert entity into datastore\n    datastore.put(matchEntity);\n  }\n\n  /** Delete matched participants from datastore */\n  private void deleteParticipantFromDatastore(Participant participant, DatastoreService datastore) {\n    Key participantEntityKey = KeyFactory.createKey(KEY_PARTICIPANT, participant.getId());\n    datastore.delete(participantEntityKey);\n  }\n\n  /** Return positive integer value, or -1 if invalid or negative */\n  private static int convertToPositiveInt(String s) {\n    if (s == null) {\n      return -1;\n    }\n    try {\n      int parsed = Integer.parseInt(s);\n      return (parsed >= 0) ? parsed : -1;\n    } catch (NumberFormatException e) {\n      return -1;\n    }\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- backend/src/main/java/com/google/sps/servlets/AddParticipantServlet.java	(revision f3fc4ff3189002ce2411a5b49fec36cbadefb128)
+++ backend/src/main/java/com/google/sps/servlets/AddParticipantServlet.java	(date 1594265991272)
@@ -12,21 +12,19 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-package com.google.sps.servlets;
+package main.java.com.google.sps.servlets;
 
-import com.google.appengine.api.datastore.DatastoreService;
-import com.google.appengine.api.datastore.DatastoreServiceFactory;
-import com.google.appengine.api.datastore.Entity;
-import com.google.appengine.api.datastore.Key;
-import com.google.appengine.api.datastore.KeyFactory;
-import com.google.appengine.api.datastore.PreparedQuery;
-import com.google.appengine.api.datastore.Query;
+import com.google.appengine.api.datastore.*;
 import com.google.appengine.api.datastore.Query.SortDirection;
 import com.google.appengine.api.users.UserService;
 import com.google.appengine.api.users.UserServiceFactory;
-import com.google.sps.FindMatchQuery;
-import com.google.sps.data.Match;
-import com.google.sps.data.Participant;
+import main.java.com.google.sps.FindMatchQuery;
+import main.java.com.google.sps.data.Match;
+import main.java.com.google.sps.data.Participant;
+import javax.servlet.annotation.WebServlet;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.time.Clock;
 import java.time.Instant;
@@ -34,10 +32,6 @@
 import java.time.ZonedDateTime;
 import java.util.ArrayList;
 import java.util.List;
-import javax.servlet.annotation.WebServlet;
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 
 /** Servlet that returns some example content. */
 @WebServlet("/api/v1/add-participant")
Index: backend/src/main/java/com/google/sps/notifs/EmailNotifier.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage main.java.com.google.sps.notifs;\n\nimport com.google.api.client.auth.oauth2.Credential;\nimport com.google.api.client.extensions.java6.auth.oauth2.AuthorizationCodeInstalledApp;\nimport com.google.api.client.extensions.jetty.auth.oauth2.LocalServerReceiver;\nimport com.google.api.client.googleapis.auth.oauth2.GoogleAuthorizationCodeFlow;\nimport com.google.api.client.googleapis.auth.oauth2.GoogleClientSecrets;\nimport com.google.api.client.googleapis.javanet.GoogleNetHttpTransport;\nimport com.google.api.client.http.javanet.NetHttpTransport;\nimport com.google.api.client.json.JsonFactory;\nimport com.google.api.client.json.jackson2.JacksonFactory;\nimport com.google.api.client.util.Base64;\nimport com.google.api.client.util.store.FileDataStoreFactory;\nimport com.google.api.services.gmail.Gmail;\nimport com.google.api.services.gmail.GmailScopes;\nimport com.google.api.services.gmail.model.Message;\nimport com.google.common.collect.ImmutableList;\nimport javax.mail.Message.RecipientType;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.security.GeneralSecurityException;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Properties;\n\n/** Class representing the notification system capable of sending mails to the user. */\npublic class EmailNotifier {\n\n  private static final String APPLICATION_NAME = \"Ad-lib\";\n  private static final String APPLICATION_EMAIL = \"Adlib-Step@gmail.com\";\n\n  private static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n  private static final String TOKENS_DIRECTORY_PATH = \"tokens\";\n  /**\n   * Global instance of the scopes required by this quickstart. If modifying these scopes, delete\n   * your previously saved tokens/ folder.\n   */\n  private static final List<String> SCOPES =\n          ImmutableList.of(GmailScopes.MAIL_GOOGLE_COM);\n\n  private static final String CREDENTIALS_FILE_PATH = \"credentials.json\";\n\n  /** Variable representing the email to be notified */\n  private final String toEmail;\n\n  private final String recipientName;\n\n  /**\n   * @param recipientName Name of the recipient of the user\n   * @param toEmail Email that this email is going to sent to.\n   */\n  public EmailNotifier(String recipientName, String toEmail) {\n    this.recipientName = recipientName;\n    this.toEmail = toEmail;\n  }\n\n  /**\n   * Creates an authorized Credential object.\n   *\n   * @param HTTP_TRANSPORT The network HTTP Transport.\n   * @return An authorized Credential object.\n   * @throws IOException If the credentials.json file cannot be found.\n   */\n  private static Credential getCredentials(final NetHttpTransport HTTP_TRANSPORT)\n          throws IOException {\n    // Load client secrets.\n    InputStream in = new FileInputStream(CREDENTIALS_FILE_PATH);\n    GoogleClientSecrets clientSecrets =\n            GoogleClientSecrets.load(JSON_FACTORY, new InputStreamReader(in));\n\n    // Build flow and trigger user authorization request.\n    GoogleAuthorizationCodeFlow flow =\n            new GoogleAuthorizationCodeFlow.Builder(\n                    HTTP_TRANSPORT, JSON_FACTORY, clientSecrets, SCOPES)\n                    .setDataStoreFactory(\n                            new FileDataStoreFactory(new File(TOKENS_DIRECTORY_PATH)))\n                    .setAccessType(\"offline\")\n                    .build();\n    LocalServerReceiver receiver = new LocalServerReceiver.Builder().setPort(8000).build();\n    return new AuthorizationCodeInstalledApp(flow, receiver).authorize(\"user\");\n  }\n\n  /**\n   * Create a MimeMessage using the parameters provided.\n   *\n   * @param toEmail email address of the receiver\n   * @param subject subject of the email\n   * @param bodyText body text of the email\n   * @return the MimeMessage to be used to send email\n   * @throws MessagingException for other failures\n   */\n  public static MimeMessage createEmail(String toEmail, String subject, String bodyText)\n          throws MessagingException {\n\n    Properties props = new Properties();\n    Session session = Session.getDefaultInstance(props, /* authenticator= */ null);\n\n    MimeMessage email = new MimeMessage(session);\n\n    email.setFrom(new InternetAddress(APPLICATION_EMAIL));\n    email.addRecipient(RecipientType.TO, new InternetAddress(toEmail));\n    email.setSubject(subject);\n    email.setText(bodyText);\n    return email;\n  }\n\n  /**\n   * Create a message from an email.\n   *\n   * @param emailContent Email to be sent to raw of message\n   * @return a message containing a base64url encoded email\n   * @throws IOException if an error occurs writing to the stream\n   * @throws MessagingException for other failures\n   */\n  public static Message createMessageWithEmail(MimeMessage emailContent)\n          throws MessagingException, IOException {\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    emailContent.writeTo(buffer);\n    byte[] bytes = buffer.toByteArray();\n    String encodedEmail = Base64.encodeBase64URLSafeString(bytes);\n    Message message = new Message();\n    message.setRaw(encodedEmail);\n    return message;\n  }\n\n  /** Getter function that returns the string representing the email recipients name . */\n  private String getRecipientName() {\n    return recipientName;\n  }\n\n  /** Function that access its api and using it sends an email */\n  //    TODO(): Create a dummy email for ad lib itself to send emails.\n  //    TODO(): Replace body to send real link to user instead of generic.\n\n  public void notifyUser() throws MessagingException, GeneralSecurityException, IOException {\n\n    MimeMessage email =\n            createEmail(\n                    getToEmail(),\n                    \"Ad-Lib Meeting Found\",\n                    \" Hey \"\n                            + getRecipientName()\n                            + \" Please Join your Ad-Lib meeting via the link below : \\n\"\n                            + \" http://meet.google.com/new\");\n    NetHttpTransport HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport();\n    Gmail service =\n            new Gmail.Builder(HTTP_TRANSPORT, JSON_FACTORY, getCredentials(HTTP_TRANSPORT))\n                    .setApplicationName(APPLICATION_NAME)\n                    .build();\n    Message messageWithEmail = createMessageWithEmail(email);\n    service.users().messages().send(\"me\", messageWithEmail).execute();\n  }\n\n  private String getToEmail() {\n    return toEmail;\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- backend/src/main/java/com/google/sps/notifs/EmailNotifier.java	(revision f3fc4ff3189002ce2411a5b49fec36cbadefb128)
+++ backend/src/main/java/com/google/sps/notifs/EmailNotifier.java	(date 1594265991289)
@@ -48,132 +48,131 @@
 /** Class representing the notification system capable of sending mails to the user. */
 public class EmailNotifier {
 
-  private static final String APPLICATION_NAME = "Ad-lib";
-  private static final String APPLICATION_EMAIL = "Adlib-Step@gmail.com";
+    private static final String APPLICATION_NAME = "Ad-lib";
+    private static final String APPLICATION_EMAIL = "Adlib-Step@gmail.com";
 
-  private static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();
-  private static final String TOKENS_DIRECTORY_PATH = "tokens";
-  /**
-   * Global instance of the scopes required by this quickstart. If modifying these scopes, delete
-   * your previously saved tokens/ folder.
-   */
-  private static final List<String> SCOPES =
-          ImmutableList.of(GmailScopes.MAIL_GOOGLE_COM);
+    private static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();
+    private static final String TOKENS_DIRECTORY_PATH = "tokens";
+    /**
+     * Global instance of the scopes required by this quickstart. If modifying these scopes, delete
+     * your previously saved tokens/ folder.
+     */
+    private static final List<String> SCOPES = ImmutableList.of(GmailScopes.MAIL_GOOGLE_COM);
 
-  private static final String CREDENTIALS_FILE_PATH = "credentials.json";
+    private static final String CREDENTIALS_FILE_PATH = "credentials.json";
 
-  /** Variable representing the email to be notified */
-  private final String toEmail;
+    /** Variable representing the email to be notified */
+    private final String toEmail;
 
-  private final String recipientName;
+    private final String recipientName;
 
-  /**
-   * @param recipientName Name of the recipient of the user
-   * @param toEmail Email that this email is going to sent to.
-   */
-  public EmailNotifier(String recipientName, String toEmail) {
-    this.recipientName = recipientName;
-    this.toEmail = toEmail;
-  }
+    /**
+     * @param recipientName Name of the recipient of the user
+     * @param toEmail Email that this email is going to sent to.
+     */
+    public EmailNotifier(String recipientName, String toEmail) {
+        this.recipientName = recipientName;
+        this.toEmail = toEmail;
+    }
 
-  /**
-   * Creates an authorized Credential object.
-   *
-   * @param HTTP_TRANSPORT The network HTTP Transport.
-   * @return An authorized Credential object.
-   * @throws IOException If the credentials.json file cannot be found.
-   */
-  private static Credential getCredentials(final NetHttpTransport HTTP_TRANSPORT)
-          throws IOException {
-    // Load client secrets.
-    InputStream in = new FileInputStream(CREDENTIALS_FILE_PATH);
-    GoogleClientSecrets clientSecrets =
-            GoogleClientSecrets.load(JSON_FACTORY, new InputStreamReader(in));
+    /**
+     * Creates an authorized Credential object.
+     *
+     * @param HTTP_TRANSPORT The network HTTP Transport.
+     * @return An authorized Credential object.
+     * @throws IOException If the credentials.json file cannot be found.
+     */
+    private static Credential getCredentials(final NetHttpTransport HTTP_TRANSPORT)
+            throws IOException {
+        // Load client secrets.
+        InputStream in = new FileInputStream(CREDENTIALS_FILE_PATH);
+        GoogleClientSecrets clientSecrets =
+                GoogleClientSecrets.load(JSON_FACTORY, new InputStreamReader(in));
 
-    // Build flow and trigger user authorization request.
-    GoogleAuthorizationCodeFlow flow =
-            new GoogleAuthorizationCodeFlow.Builder(
-                    HTTP_TRANSPORT, JSON_FACTORY, clientSecrets, SCOPES)
-                    .setDataStoreFactory(
-                            new FileDataStoreFactory(new File(TOKENS_DIRECTORY_PATH)))
-                    .setAccessType("offline")
-                    .build();
-    LocalServerReceiver receiver = new LocalServerReceiver.Builder().setPort(8000).build();
-    return new AuthorizationCodeInstalledApp(flow, receiver).authorize("user");
-  }
+        // Build flow and trigger user authorization request.
+        GoogleAuthorizationCodeFlow flow =
+                new GoogleAuthorizationCodeFlow.Builder(
+                                HTTP_TRANSPORT, JSON_FACTORY, clientSecrets, SCOPES)
+                        .setDataStoreFactory(
+                                new FileDataStoreFactory(new File(TOKENS_DIRECTORY_PATH)))
+                        .setAccessType("offline")
+                        .build();
+        LocalServerReceiver receiver = new LocalServerReceiver.Builder().setPort(8000).build();
+        return new AuthorizationCodeInstalledApp(flow, receiver).authorize("user");
+    }
 
-  /**
-   * Create a MimeMessage using the parameters provided.
-   *
-   * @param toEmail email address of the receiver
-   * @param subject subject of the email
-   * @param bodyText body text of the email
-   * @return the MimeMessage to be used to send email
-   * @throws MessagingException for other failures
-   */
-  public static MimeMessage createEmail(String toEmail, String subject, String bodyText)
-          throws MessagingException {
+    /**
+     * Create a MimeMessage using the parameters provided.
+     *
+     * @param toEmail email address of the receiver
+     * @param subject subject of the email
+     * @param bodyText body text of the email
+     * @return the MimeMessage to be used to send email
+     * @throws MessagingException for other failures
+     */
+    public static MimeMessage createEmail(String toEmail, String subject, String bodyText)
+            throws MessagingException {
 
-    Properties props = new Properties();
-    Session session = Session.getDefaultInstance(props, /* authenticator= */ null);
+        Properties props = new Properties();
+        Session session = Session.getDefaultInstance(props, /* authenticator= */ null);
 
-    MimeMessage email = new MimeMessage(session);
+        MimeMessage email = new MimeMessage(session);
 
-    email.setFrom(new InternetAddress(APPLICATION_EMAIL));
-    email.addRecipient(RecipientType.TO, new InternetAddress(toEmail));
-    email.setSubject(subject);
-    email.setText(bodyText);
-    return email;
-  }
+        email.setFrom(new InternetAddress(APPLICATION_EMAIL));
+        email.addRecipient(RecipientType.TO, new InternetAddress(toEmail));
+        email.setSubject(subject);
+        email.setText(bodyText);
+        return email;
+    }
 
-  /**
-   * Create a message from an email.
-   *
-   * @param emailContent Email to be sent to raw of message
-   * @return a message containing a base64url encoded email
-   * @throws IOException if an error occurs writing to the stream
-   * @throws MessagingException for other failures
-   */
-  public static Message createMessageWithEmail(MimeMessage emailContent)
-          throws MessagingException, IOException {
-    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
-    emailContent.writeTo(buffer);
-    byte[] bytes = buffer.toByteArray();
-    String encodedEmail = Base64.encodeBase64URLSafeString(bytes);
-    Message message = new Message();
-    message.setRaw(encodedEmail);
-    return message;
-  }
+    /**
+     * Create a message from an email.
+     *
+     * @param emailContent Email to be sent to raw of message
+     * @return a message containing a base64url encoded email
+     * @throws IOException if an error occurs writing to the stream
+     * @throws MessagingException for other failures
+     */
+    public static Message createMessageWithEmail(MimeMessage emailContent)
+            throws MessagingException, IOException {
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+        emailContent.writeTo(buffer);
+        byte[] bytes = buffer.toByteArray();
+        String encodedEmail = Base64.encodeBase64URLSafeString(bytes);
+        Message message = new Message();
+        message.setRaw(encodedEmail);
+        return message;
+    }
 
-  /** Getter function that returns the string representing the email recipients name . */
-  private String getRecipientName() {
-    return recipientName;
-  }
+    /** Getter function that returns the string representing the email recipients name . */
+    private String getRecipientName() {
+        return recipientName;
+    }
 
-  /** Function that access its api and using it sends an email */
-  //    TODO(): Create a dummy email for ad lib itself to send emails.
-  //    TODO(): Replace body to send real link to user instead of generic.
+    /** Function that access its api and using it sends an email */
+    //    TODO(): Create a dummy email for ad lib itself to send emails.
+    //    TODO(): Replace body to send real link to user instead of generic.
 
-  public void notifyUser() throws MessagingException, GeneralSecurityException, IOException {
+    public void notifyUser() throws MessagingException, GeneralSecurityException, IOException {
 
-    MimeMessage email =
-            createEmail(
-                    getToEmail(),
-                    "Ad-Lib Meeting Found",
-                    " Hey "
-                            + getRecipientName()
-                            + " Please Join your Ad-Lib meeting via the link below : \n"
-                            + " http://meet.google.com/new");
-    NetHttpTransport HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport();
-    Gmail service =
-            new Gmail.Builder(HTTP_TRANSPORT, JSON_FACTORY, getCredentials(HTTP_TRANSPORT))
-                    .setApplicationName(APPLICATION_NAME)
-                    .build();
-    Message messageWithEmail = createMessageWithEmail(email);
-    service.users().messages().send("me", messageWithEmail).execute();
-  }
+        MimeMessage email =
+                createEmail(
+                        getToEmail(),
+                        "Ad-Lib Meeting Found",
+                        " Hey "
+                                + getRecipientName()
+                                + " Please Join your Ad-Lib meeting via the link below : \n"
+                                + " http://meet.google.com/new");
+        NetHttpTransport HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport();
+        Gmail service =
+                new Gmail.Builder(HTTP_TRANSPORT, JSON_FACTORY, getCredentials(HTTP_TRANSPORT))
+                        .setApplicationName(APPLICATION_NAME)
+                        .build();
+        Message messageWithEmail = createMessageWithEmail(email);
+        service.users().messages().send("me", messageWithEmail).execute();
+    }
 
-  private String getToEmail() {
-    return toEmail;
-  }
+    private String getToEmail() {
+        return toEmail;
+    }
 }
